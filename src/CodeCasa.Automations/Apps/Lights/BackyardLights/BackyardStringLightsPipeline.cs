using System.Reactive.Concurrency;
using AutomationPipelines;
using CodeCasa.AutoGenerated;
using CodeCasa.AutoGenerated.Extensions;
using CodeCasa.NetDaemon.Utilities;
using CodeCasa.NetDaemon.Utilities.Extensions;
using NetDaemon.AppModel;

namespace CodeCasa.Automations.Apps.Lights.BackyardLights;

[NetDaemonApp]
internal class BackyardStringLightsPipeline
{
    public BackyardStringLightsPipeline(
        IPipeline<bool> backyardPorchStringLightsPipeline,
        IPipeline<bool> backyardPergolaStringLightsPipeline,
        IPipeline<bool> backyardFenceStringLightsPipeline,
        IPipeline<LightParameters> backyardGarageLightPipeline,
        IPipeline<LightParameters> backyardEntranceLightPipeline,
        IPipeline<LightParameters> backyardDoorLightPipeline,
        LightEntities lightEntities,
        IScheduler scheduler)
    {
        // We use a separate pipeline for each light string to allow for different timing on the startup routine.
        // This results in a nice animation, in which lights are turned on one by one.
        backyardPorchStringLightsPipeline
            .SetDefault(false)
            .RegisterNode(new LightStringRoutineNode<bool>(scheduler, true, TimeSpan.Zero))
            .RegisterNode<BackyardStringLightsEnergySavingNode>()
            .SetOutputHandler(b => UpdateLightState(lightEntities.BackyardPorchStringLights, b));

        backyardPergolaStringLightsPipeline
            .SetDefault(false)
            .RegisterNode(new LightStringRoutineNode<bool>(scheduler, true, TimeSpan.FromSeconds(1)))
            .RegisterNode<BackyardStringLightsEnergySavingNode>()
            .SetOutputHandler(b => UpdateLightState(lightEntities.BackyardPergolaStringLights, b));

        backyardFenceStringLightsPipeline
            .SetDefault(false)
            .RegisterNode(new LightStringRoutineNode<bool>(scheduler, true, TimeSpan.FromSeconds(2)))
            .RegisterNode<BackyardStringLightsEnergySavingNode>()
            .SetOutputHandler(b => UpdateLightState(lightEntities.BackyardFenceStringLights, b));

        // All other lights should turn on slowly at the same time.
        // Note: We could actually use a single pipeline for this. But as we generate parameters based on light entity, I split them up. This way, even if the light type changes, this implementation will still work.
        const int transitionSeconds = 4;
        const int offsetSeconds = 10;
        backyardGarageLightPipeline
            .SetDefault(LightParameters.Off())
            .RegisterNode(new LightStringRoutineNode<LightParameters>(scheduler,
                lightEntities.BackyardGarageLight.GetRelaxSceneParameters() with { Transition = TimeSpan.FromSeconds(transitionSeconds) },
                TimeSpan.FromSeconds(offsetSeconds)))
            .RegisterNode<BackyardCoachLightsEnergySavingNode>()
            .SetOutputHandler(lightEntities.BackyardGarageLight.ExecuteLightParameters);

        backyardEntranceLightPipeline
            .SetDefault(LightParameters.Off())
            .RegisterNode(new LightStringRoutineNode<LightParameters>(scheduler,
                lightEntities.BackyardEntranceLight.GetRelaxSceneParameters() with { Transition = TimeSpan.FromSeconds(transitionSeconds) },
                TimeSpan.FromSeconds(offsetSeconds)))
            .RegisterNode<BackyardCoachLightsEnergySavingNode>()
            .SetOutputHandler(lightEntities.BackyardEntranceLight.ExecuteLightParameters);

        backyardDoorLightPipeline
            .SetDefault(LightParameters.Off())
            .RegisterNode(new LightStringRoutineNode<LightParameters>(scheduler,
                lightEntities.BackyardDoorLight.GetRelaxSceneParameters() with { Transition = TimeSpan.FromSeconds(transitionSeconds) },
                TimeSpan.FromSeconds(offsetSeconds)))
            .RegisterNode<BackyardCoachLightsEnergySavingNode>()
            .SetOutputHandler(lightEntities.BackyardDoorLight.ExecuteLightParameters);
    }

    private static void UpdateLightState(LightEntity lightEntity, bool state)
    {
        if (state)
        {
            lightEntity.TurnOn();
        }
        else
        {
            lightEntity.TurnOff();
        }
    }
}