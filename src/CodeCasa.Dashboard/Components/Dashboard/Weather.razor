@using System.Globalization
@using CodeCasa.AutoGenerated
@using CodeCasa.CustomEntities.Core.Weather
@using CodeCasa.Dashboard.Resolvers
@using global::NetDaemon.HassModel.Entities

@inject SensorEntities SensorEntities;
@inject ForecastHome ForecastHome;

<div class="temp-container @(Visible ? "visible" : "hidden")">
    <MudStack Row AlignItems="AlignItems.Center">
        @if (_outsideTemperature == null)
        {
            <MudText Typo="Typo.h6" Color="Color.Error">??°</MudText>
        }
        else
        {
            <MudText Typo="Typo.h6" Color="Color.Info"> @($"{_outsideTemperature.Value.ToString("0.#", new CultureInfo("nl-NL"))}")°</MudText>
        }
        @if (_weatherType == null)
        {
            <MudIcon Icon="@Icons.Material.Filled.Nature" />
        }
        else
        {
            // todo: why is the style not working?
            <span class="material-symbols-outlined" style="font-variation-settings: 'FILL' 1;">@(WeatherIcons.GetIcon(_weatherType.Value))</span>
        }
        <MudText Typo="Typo.h6">/</MudText>
        @if (_livingRoomTemperature == null)
        {
            <MudText Typo="Typo.h6" Color="Color.Error">??°</MudText>
        }
        else
        {
            <MudText Typo="Typo.h6" Color="Color.Success"> @($"{_livingRoomTemperature.Value.ToString("0.#", new CultureInfo("nl-NL"))}")°</MudText>
        }
        <MudIcon Icon="@Icons.Material.Filled.Home" />
    </MudStack>
</div>

@code {

    [Parameter] public bool Visible { get; set; } = true;

    private double? _livingRoomTemperature;
    private double? _outsideTemperature;
    private WeatherTypes? _weatherType;

    protected override void OnInitialized()
    {
        SensorEntities.LivingRoomTemperature.StateAllChangesWithCurrent().Subscribe(stateChange =>
        {
            var newTemp = stateChange.New?.State;
            if (newTemp == null || newTemp == _livingRoomTemperature)
            {
                return;
            }
            _livingRoomTemperature = newTemp;
            InvokeAsync(StateHasChanged);
        });
        SensorEntities.MeteorologiskTemperature.StateAllChangesWithCurrent().Subscribe(stateChange =>
        {
            var newTemp = stateChange.New?.State;
            if (newTemp == null || newTemp == _outsideTemperature)
            {
                return;
            }
            _outsideTemperature = newTemp;
            InvokeAsync(StateHasChanged);
        });
        ForecastHome.StateAllChangesWithCurrent().Subscribe(stateChange =>
        {
            var weatherType = stateChange.New?.State;
            if (weatherType == null)
            {
                return;
            }

            _weatherType = weatherType;
            InvokeAsync(StateHasChanged);
        });
    }
}

<style>
    .temp-container {
        text-align: center; /* center text inside */
        position: fixed;
        pointer-events: none;
        bottom: 12px;
        right: 20px;
        overflow-y: auto;
    opacity: 0;
    transition: opacity 0.5s ease-in-out;
}

.visible {
    opacity: 1;
}

.hidden {
    opacity: 0;
}
</style>